<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.sw.ge.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="px-handle.html" />


<!--
Allow the user to select a value or range of values within a specified min and max.

##### Usage

    <px-slider value="50" min="1" max="100"></px-slider>

@element px-slider
@blurb Allow the user to select a value or range of values within a specified min and max.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-slider">
  <link rel="import" type="css" href="css/px-slider.css" />
  <template>
    <div class="flex">
      <input id="inputStart" type="text" class="text-input" value="{{value}}" on-change="handleStartChange" />
      <div id="sliderContainer" class="slider flex__item" on-click="jumpToValue">
        <div id="sliderSelected" class="slider__selected"></div>
        <px-handle id="startHandle" style="visibility:hidden;" handle-track-event-name="handleTrackStart" on-track="handleTrackStart"></px-handle>
        <px-handle id="endHandle" handle-track-event-name="handleTrackEnd" on-track="handleTrackEnd"></px-handle>
      </div>
      <input id="inputEnd" type="text" style="visibility:hidden;" class="text-input" value="{{endValue}}" on-change="handleEndChange" />
    </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-slider',

    ready: function() {
      // Do we have a start value and end value?
      if (this.startValue && this.endValue) {
        // If so, this is a range.
        this._setRange(true);
        this.value = this.startValue;

        // Show the start handle and the end input
        this.$.startHandle.style.visibility = 'visible';
        this.$.inputEnd.style.visibility = 'visible';

        // Have to wait for the DOM to finish loading
        // And then refire these
        this.async(function() {
          this._updateHandle(this.$.startHandle, this.value);
          this._updateHandle(this.$.endHandle, this.endValue);
        }, 1);
      } else {
        this.async(function() {
          this._updateHandle(this.$.endHandle, this.value);
        }, 1);
      }
    },

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {
      range: {
        type: Boolean,
        value: false,
        readOnly: true
      },
      value: {
        type: Number,
        reflect: true,
        notify: true,
        observer: '_valueChanged'
      },
      startValue: {
        type: Number,
        reflect: true,
        notify: true,
        observer: '_startValueChanged'
      },
      endValue: {
        type: Number,
        reflect: true,
        notify: true,
        observer: '_endValueChanged'
      },
      min: {
        type: Number,
        value: 1,
        reflect: true
      },
      max: {
        type: Number,
        value: 100,
        reflect: true
      },
      step: {
        type: Number,
        value: 1,
        reflect: true
      },
      disabled: {
        type: Boolean,
        value: false,
        reflect: true
      }
    },

    /**
     * Watchers (creepy)
     *
     * Not working, though ...
     *
     */
    _valueChanged: function(newValue, oldValue) {
      var clean = this._cleanValue(newValue);

      // If this is a range, don't go higher than the end value
      if (this.range && clean > this.endValue) {
        clean = this.endValue;
      }

      // If it's a range, we update the start handle; otherwise update the end handle
      var handle = (this.range) ? this.$.startHandle : this.$.endHandle;
      this._updateHandle(handle, this.value);

      // For the sake of ranges, we keep start value and value in sync
      this.startValue = clean;
      this.value = clean;
    },

    _startValueChanged: function(newValue, oldValue) {
      // This is just really here in case a dev changes this value programmatically
      //this.value = newValue; // Should call value watcher for cleanup
    },

    _endValueChanged: function(newValue, oldValue) {
      var clean = this._cleanValue(newValue);

      // If this is a range, don't go below the start value
      if (this.range && clean < this.value) {
        clean = this.value;
      }

      // Update the end handle
      this._updateHandle(this.$.endHandle, clean);

      // Update endValue with the cleaned value
      this.endValue = clean;
    },

    _cleanValue: function(dirty) {
      var clean = dirty;

      // Account for 'steps'
      var stepchange = dirty % this.step;
      clean -= stepchange;
      if (stepchange > (this.step / 2)) {
        clean += this.step;
      }

      // Check against min and max values
      if (dirty > this.max) {
        clean = this.max;
      } else if (dirty < this.min) {
        clean = this.min;
      }

      return clean;
    },

    _translateValueToPosition: function(myvalue) {
      // add offset so end handle stops at end of tracking
      var cO = 22;
      var cW = this.$.sliderContainer.offsetWidth - cO;

      // What is the ratio of the value to the max?
      var ratio = myvalue / this.max;

      // Multiple by the width of the container
      var position = ratio * cW;

      return position + 'px';
    },

    _translatePositionToValue: function(mypos) {
      // add offset so end handle stops at end of tracking
      var cO = 22;
      var cW = this.$.sliderContainer.offsetWidth - cO;

      // Have we loaded the container?
      if (cW === 0) {
        return;
      }

      // What is the ratio of my position to the container?
      var ratio = mypos / cW;

      // Convert to value; have to account min values other than 0
      var value = ratio * (this.max - this.min);

      return this._cleanValue(value);
    },

    _updateHandle: function(handle, value) {
      // Determine new x position form value
      var newPos = this._translateValueToPosition(value);

      // Set px value of left position
      handle.style.left = newPos;

      // Update the progress bar, too
      this._updateProgressBar();
    },

    /**
     * Update the progress bar based on change in values
     *
     * @method handleChange
     */
    _updateProgressBar: function() {
      // Value is coming up as undefined, for some reason
      // 0 value is ok, though.
      if (!this.value && this.value !== 0) {
        return;
      }

      // Am I a range or a single value?
      var progressValue = (this.range) ? this.endValue - this.value : this.value;
      var progressPosition = (this.range) ? this.value : 0;

      // Set the width and the position (for ranges)
      this.$.sliderSelected.style.width = this._translateValueToPosition(progressValue);
      this.$.sliderSelected.style.left = this._translateValueToPosition(progressPosition);
    },

    /**
     * Where is the mouse in relation to the slider? Keep it in bounds.
     *
     * @method _findPosition
     */
    _findPosition: function(event) {
      // Is this a drag or a click?
      var mX = (event.detail.x) ? event.detail.x : event.clientX;
      // add offset so end handle stops at end of tracking
      var cO = 22;
      var cL = this.$.sliderContainer.getBoundingClientRect().left;
      var cR = this.$.sliderContainer.getBoundingClientRect().right;
      var cW = this.$.sliderContainer.offsetWidth - cO;
      var position = 0;

      if (mX > cR) {
        // Is the mouse passed the right of our container?
        // If so, set the position to the width of the container
        position = cW;
      } else if (mX < cL) {
        // Is the mouse passed the left of our container?
        // If so, set the position to zero
        position = 0;
      } else {
        // Otherwise, position is based on the mouseX minus the offset
        position = mX - cL;
      }

      return position;
    },

    /**
     * Handles updating the value when the START handle is moved
     *
     * @method handleTrackStart
     */
    handleTrackStart: function(event) {
      var newPos = this._findPosition(event);

      // Update the value for the new position
      var newValue = this._translatePositionToValue(newPos);

      // We know this is range
      if (newValue > this.endValue) {
        newValue = this.endValue;
      }
      this.value = newValue;
    },

    /**
     * Handles updating the value when the END handle is moved
     *
     * @method handleEndChange
     */
    handleTrackEnd: function(event) {
      var newPos = this._findPosition(event);

      // Update the value based on the new position
      var newValue = this._translatePositionToValue(newPos);
      if (this.range) {
        if (newValue < this.value) {
          newValue = this.value;
        }
        this.endValue = newValue;
      } else {
        this.value = newValue;
      }
    },

    /**
     * Handles updating the value when the START input textbox is changed
     *
     * @method handleStartChange
     */
    handleStartChange: function(event) {
      // Two way data binding not working?
      this.value = this.$.inputStart.value;
    },

    /**
     * Handles updating the value when the END input textbox is changed
     *
     * @method handleEndChange
     */
    handleEndChange: function(event) {
      // Two way data binding not working?
      this.endValue = this.$.inputEnd.value;
    },

    /**
     * When the user clicks on the slider itself, jump to the corresponding value.
     *
     * @method jumpToValue
     */
    jumpToValue: function(event) {
      var newPos = this._findPosition(event);

      // Update the value based on the new position
      var newValue = this._translatePositionToValue(newPos);

      if (this.range) {
        // Which handle do you move?
        if (newValue < this.value) {
          // If it's less than the start value, move the left slider
          this.value = newValue;

        } else if (newValue > this.endValue) {
          // If it's greater than the start value, move the right slider
          this.endValue = newValue;
        } else {
          // We are somewhere in the middle - which handle do we move?!
        }

      } else {
        // Move the only handle
        this.value = newValue;
      }
    }
  });
</script>
