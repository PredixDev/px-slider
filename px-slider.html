<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html"/>
<link rel="import" href="../px-vis/px-vis-behavior-d3.html" />
<link rel="import" href="../px-number-formatter/px-number-formatter-behavior.html" />
<link rel="import" href="../px-number-formatter/px-number-formatter-no-display.html" />

<link rel="import" href="px-handle.html" />
<link rel="import" href="px-handle-multi.html" />


<!--
Allow the user to select a value or range of values within a specified min and max.

##### Usage

    <px-slider value="50" min="1" max="100"></px-slider>

### Styling
The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--px-slider-border-color` | Border color for the unselected portion of the slider | `$gray5`
`--px-slider-background-color` | Background color for the unselected portion of the slider | `$gray1`
`--px-slider-border-color--selected` | Border color for the selected portion of the slider | `$select-blue-pressed`
`--px-slider-background-color--selected` | Background color for the selected portion of the slider | `$select-blue-default`
`--px-handle-border-color` | Border color for the slider's handle | `$gray5`
`--px-handle-border-color--disabled` | Border color for the handle when disabled | `$gray4`
`--px-handle-stroke-color` | Color of the small lines on the slider handle | `$gray6`
`--px-handle-background-color` | Background color for the handle | `$white`
`--px-handle-background-color--hover` | Background color when the handle is pressed | `$gray7`
`--px-handle-shadow-color` | Color of the drop shadow on the slider handle | `$black`

@element px-slider
@blurb Allow the user to select a value or range of values within a specified min and max.
@homepage index.html
@demo index.html
-->

<link rel="import" href="css/px-slider-styles.html">
<link rel="import" href="css/px-handle-styles.html">

<dom-module id="px-slider">
  <template>
  <style include="px-slider-styles"></style>
  <style include="px-handle-styles"></style>

  <div id="wrapper" class="flex">
    <template is="dom-if" if="[[_showStartInput]]">
      <input id="inputStart"
        type="text"
        class="text-input input--tiny flex__item--no-grow"
        value="[[formattedStartValue]]"
        on-change="_inputChangedStart"
        tabindex="0"
        disabled="{{disabled}}"/>
    </template>
    <px-number-formatter-no-display
      id="formatterStart"
      value="[[value]]"
      formatted-value="{{formattedStartValue}}"
      format="[[_format]]"
      currency="[[currency]]"
      culture="[[culture]]"
      zero-format="[[zeroFormat]]">
    </px-number-formatter-no-display>

    <svg
      xmlns="http://www.w3.org/2000/svg"
      id="sliderSVG"
      class="flex__item--no-grow"
      overflow="hidden"
      width$="[[_getSvgWith(_width, _margin.*)]]"
      height$="[[_getSvgHeight(_height, _margin.*)]]">
      <g id="slider" transform$="[[_calcTransform(_margin.*)]]">
        <g id="backgroundTrack">
          <rect class="backgroundTrack sliderTrack" x="0" y="0" rx="2" ry="2" width$="[[_width]]" height="10"/>
        </g>
        <g id="zoneBars"></g>
        <g id="progressBar">
          <rect class="progressBar sliderTrack" x="[[_calcProgressStart(value, endValue, _scaleChanged)]]" y="0" rx="2" ry="2" width$="[[_calcProgressEnd(value, endValue, _scaleChanged)]]" height="10"/>
        </g>

        <g id="multiHandles">
          <g id="handleTargetStart" on-down="handleDown" on-up="handleUp" on-track="handleTrack" tabindex="-1">
            <!-- <path id="handleDropShadow" d="M0.76,12.26V4.67a3,3,0,0,1,3-3h15a3,3,0,0,1,3,3v7.59l-10,8.41h-1Z"/>
            <path id="handleBody" d="M0.76,11.26V3.67a3,3,0,0,1,3-3h15a3,3,0,0,1,3,3v7.59l-10,8.41h-1Z"/>
            <line class="handleLines" x1="14.09" y1="11" x2="14.09" y2="4"/>
            <line class="handleLines" x1="8.09" y1="11" x2="8.09" y2="4"/>
            <line class="handleLines" x1="11.09" y1="11" x2="11.09" y2="4"/> -->
          </g>
          <g id="handleTargetEnd" on-down="handleDown" on-up="handleUp" on-track="handleTrack" tabindex="-1">
            <!-- <path id="handleDropShadow" d="M0.76,12.26V4.67a3,3,0,0,1,3-3h15a3,3,0,0,1,3,3v7.59l-10,8.41h-1Z"/>
            <path id="handleBody" d="M0.76,11.26V3.67a3,3,0,0,1,3-3h15a3,3,0,0,1,3,3v7.59l-10,8.41h-1Z"/>
            <line class="handleLines" x1="14.09" y1="11" x2="14.09" y2="4"/>
            <line class="handleLines" x1="8.09" y1="11" x2="8.09" y2="4"/>
            <line class="handleLines" x1="11.09" y1="11" x2="11.09" y2="4"/> -->
          </g>
        </g>

        <g id="singleHandle" class="handleGroup">
          <rect class="handleDropShadow" width="21" height="21" x="-10.5" y="-4" rx="3" ry="3"/>
          <rect class="handleBody" width="21" height="21" x="-10.5" y="-5" rx="3" ry="3"/>
          <line class="handleLines" x1="-3.5" x2="-3.5" y1="2" y2="9"/>
          <line class="handleLines" x1="0" x2="0" y1="2" y2="9"/>
          <line class="handleLines" x1="3.5" x2="3.5" y1="2" y2="9"/>
        </g>
      </g>
    </svg>

    <template is="dom-if" if="[[_showEndInput]]">
      <input id="inputEnd"
        type="text"
        class="text-input input--tiny flex__item--no-grow" value="{{endValue}}" on-change="_handleEndChange" tabindex="0" disabled="{{disabled}}"/>
    </template>
  </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-slider',

    behaviors: [
      Polymer.IronResizableBehavior,
      PxNumberFormatter.commonProperties
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {

      _height: {
        type: Number,
        value: 52
      },

      _width: {
        type: Number,
        value: 52
      },

      _margin:{
        type:Object,
        notify: true,
        value: function() {
          return {
            left: 11,
            right: 11,
            top: 21,
            bottom: 21
          };
        }
      },

      /**
       * The starting value for the slider's handle.
       */
      value: {
        type: Number,
        notify: true,
        value: 0
      },

      /**
       * For multi-handled/ranged sliders, the value of the left handle or start of the selected range.
       */
      startValue: {
        type: Number,
        notify: true
      },

      /**
       * For multi-handled/ranged sliders, the value of the right handle or end of the selected range.
       */
      endValue: {
        type: Number,
        notify: true,
        value: null,
        observer: '_endValueChanged'
      },

      /**
       * The display value for the start input box
       */
      formattedStartValue: {
        type: String
      },

      /**
       * The display value for the end input box
       */
      formattedEndValue: {
        type: String
      },

      /**
       * A min value for the slider. The user cannot choose less than the min.
       */
      min: {
        type: Number,
        value: 1,
        observer: '_minOrMaxChanged'
      },
      /**
       * A max value for the slider. The user cannot choose greater than the max.
       */
      max: {
        type: Number,
        value: 100,
        observer: '_minOrMaxChanged'
      },
      /**
       * A trigger that is greater than 0 if the min and max are valid
       */
      _minMaxValid: {
        type: Number,
        value: 0
      },
      /**
       * All allowed values will be a multiple of the step.
       * So if you want the user only to be able to select 10, 20, 30, 40, etc. you would set the step to 10.
       * The default is 1, which ensures that you only get integers for your value.
       */
      step: {
        type: Number,
        value: 1,
        observer: '_stepChanged'
      },
      /**
       * A boolean reflecting whether the slider is disabled or not.
       */
      disabled: {
        type: Boolean,
        value: false
      },

      /**
       * A boolean reflecting whether the text input fields should be hidden.
       */
      hideInputs: {
        type: Boolean,
        value: false,
        observer: '_hideInputsChanged'
      },
      /**
       * A boolean specifying if the first input box should be shown
       */
      _showStartInput: {
        type: Boolean,
        value: true
      },
      /**
       * A boolean specifying if the second input box should be shown
       */
      _showEndInput: {
        type: Boolean,
        value: false
      },

      /**
       * Boolean specifying if we are dealing with a single number or a range
       */
      _isRange: {
        type: Boolean,
        value: false
      },
      /**
       * The scale by which the slider operates - currently supports:
       * - `linear`
       * - `logarithmic`
       * - `exponential`
       */
      scale: {
        type: String,
        value: "linear",
        observer: '_createScale'
      },

      /**
       * A trigger for changes in the scale range or domain
       */
      _scaleChanged: {
        type: Boolean
      },

      /**
       * The base number for logarithmic scales
       */
      base: {
        type: Number,
        value: 10
      },
      /**
       * The exponent number for exponential scales
       */
      exponent: {
        type: Number,
        value: 1
      },

      /**
       * Holder for the scale function
       */
      _scale: {
        type: Object
      },

      /**
       * A holder for the handle d3 selected elem
       */
      _singleHandle: {
        type: Object
      },
      /**
       * A holder for the handle d3 selected elem
       */
      _startHandle: {
        type: Object
      },
      /**
       * A holder for the handle d3 selected elem
       */
      _endHandle: {
        type: Object
      },

      /**
       * Calculated format used to format the input box strings
       */
      _format: {
        type: String,
        value: "0"
      }

    },

    observers: [
      '_setRange(_scale, _width, _height)',
      '_setDomain(_scale, _minMaxValid)',
      '_valueChanged(value, _scale, _scaleChanged)',
      '_updateFormat(step)',
      '_updateFormat(format)'
    ],

    listeners: {
      'iron-resize': '_onIronResize'
    },

    ready: function() {
      window.requestAnimationFrame(this._animationFrame.bind(this));
      this._checkRange();
    },

    _animationFrame: function() {

      var singleHandle = Px.d3.select(this.$$('#singleHandle'));
      this._setupHandle(singleHandle, 'value');
      this.set('_singleHandle', singleHandle);

      var startHandle = Px.d3.select(this.$$('#multiHandleStart'));
      this._setupHandle(startHandle, 'value');
      this.set('_startHandle', startHandle);

      var endHandle = Px.d3.select(this.$$('#multiHandleEnd'));
      this._setupHandle(endHandle, 'endValue');
      this.set('_endHandle', endHandle);

      var self = this;
      var interactionRects = Px.d3.selectAll(Polymer.dom(this.$$('#sliderSVG')).querySelectorAll('.sliderTrack'));
      interactionRects.on('click', function() {
        var val = d3.mouse(this)[0];
        // TODO vertical: [1]

        if(this._isRange) {
          //check to see which is closer
        } else {
          self._calcSliderValue(val, 'value');
        }
      });
    },

    _setupHandle: function(handle, valueVar) {
      var handleBody = handle.select('.handleBody'),
          handleLines = handle.selectAll('.handleLines'),
          handleShadow = handle.select('.handleDropShadow');

      handle.call(d3.drag()
        .on("start.interrupt", function() { handle.interrupt(); })
        .on("start drag", function() {
          // apply styling
          handleBody.classed("handleBodyPressed", true);
          handleLines.classed("handleLinesPressed", true);
          handleShadow.classed("handleDropShadowPressed", true);
// TODO for vertical: check state, d3.event.y
          this._calcSliderValue(d3.event.x, valueVar);

        }.bind(this))
       .on("end", function() {
          handleBody.classed("handleBodyPressed", false);
          handleLines.classed("handleLinesPressed", false);
          handleShadow.classed("handleDropShadowPressed", false);
        })
      )
      .on("mouseenter", function() {
        handleBody.classed("handleBodyHover", true);
        handleLines.classed("handleBodyHover", true);
      })
      .on("mouseleave", function() {
        handleBody.classed("handleBodyHover", false);
        handleLines.classed("handleBodyHover", false);
      });
    },

    _onIronResize: function() {
      if(this.preventResize) {
        return;
      }
      this.debounce('ironresize', function() {
        // TODO vertical version
        // check if type is vertical; if so set height, otherwise set width
        var wrapperRect = this.$.wrapper.getBoundingClientRect(),
            startInput = this.$$('#inputStart'),
            endInput = this.$$('#inputEnd'),
            startInputSize = startInput ? startInput.getBoundingClientRect().width : 0,
            startInputMargin = startInput ? Number(window.getComputedStyle(startInput).marginRight.split('px')[0]) : 0,
            endInputSize = endInput ? endInput.getBoundingClientRect().width : 0,
            endInputMargin = endInput ? Number(window.getComputedStyle(endInput).marginLeft.split('px')[0]) : 0,
            w = wrapperRect.width - startInputSize - endInputSize - startInputMargin - endInputMargin - this._margin.left - this._margin.right;

        this.set('_width', Math.max(w, 0));
        // this.set('_height', Math.max(h, 0));
      }, 10);
    },

    _hideInputsChanged: function() {
      if(this.hideInputs) {
        this.set('_showStartInput', false);
        this.set('_showEndInput', false);
      } else {
        this.set('_showStartInput', true);
        this.set('_showEndInput', this._isRange);
      }

      this.notifyResize();
    },

    _getSvgWith: function() {
      return this._width + this._margin.left + this._margin.right
    },

    _getSvgHeight: function() {
      return this._height + this._margin.top + this._margin.bottom
    },

    _checkRange: function() {
      if(this.endValue || this.endValue === 0) {
        this.set('_isRange', true);
      } else {
        this.set('_isRange', false);
      }
    },

    _stepChanged: function() {
      // validate step
      if(this.step < 0) {
        console.warn("Improper configuration: step cannot be negative. Falling back to absolute value");
        this.set('step', Math.abs(this.step));
        return;
      }

      if(this.step === 0) {
        console.warn("Improper configuration: step cannot be negative. Falling back to 1");
        this.set('step', 1);
        return;
      }
    },

    _minOrMaxChanged: function() {
      this.debounce('_minOrMaxChanged', function() {
        var min, max;
        //check that min is less than max
        if(this.min === this.max) {
          this.set('minMaxValid', 0);
          console.warn("Improper configuration: min and max are the same. Increasing max by step size.")
          this.set('max', this.min + this.step);
          return;
        }

        if(this.min > this.max) {
          this.set('minMaxValid', 0);
          console.warn("Improper configuration: min and max are reversed. Swapping them.")
          var temp = this.min;
          this.set('min', this.max);
          this.set('max', temp);
          return;
        }

        // validation passes; set domain
        this.set('_minMaxValid', this._minMaxValid + 1);
      }, 10);
    },

    _createScale: function() {
      this.debounce('_createScale', function() {
        this._createScaleDebounced();
      }, 10);
    },

    _createScaleDebounced: function() {
      var scale;
      if(this.scale === 'linear') {
        scale = Px.d3.scaleLinear().clamp(true);
      } else if(this.scale === 'logarithmic') {
        scale = Px.d3.scaleLog().base(this.base).clamp(true);
      } else if(this.scale === 'exponential') {
        scale = Px.d3.scalePow().exponent(this.exponent).clamp(true);
      }

      // TODO Quantize etc

      this.set('_scale', scale);
    },

    _setRange: function() {
      this.debounce('_setRange', function() {
        if(this._scale && this._width && this._height) {
          this._setRangeDebouced();
        }
      }, 10);
    },

    _setRangeDebouced: function() {
      if(this.orientation === 'vertical') {
        var h = Math.max(this._height, 0),
            range = [h, 0];

      } else {
        var w = Math.max(this._width, 0),
            range = [0, w];
      }

      this._scale.range(range);

      // force a recalc
      this._scaleChanged = !this._scaleChanged;
    },

    _setDomain: function() {
      this.debounce('_setDomain', function() {
        if(this._scale && this._minMaxValid) {
          this._setDomainDebounced();
        }
      }, 10);
    },

    _setDomainDebounced: function() {
      if(this._isRange) {
        // two scales
        // one for start one for end
      } else {
        this._scale.domain([this.min, this.max]);
      }

      // force a recalc
      this._scaleChanged = !this._scaleChanged;
    },

    _calcSliderValue: function(mouseVal, valueVar) {
      this.debounce('_calcSliderValue', function() {
        this._calcSliderValueDebounced(mouseVal, valueVar);
      }, 10);
    },

    _calcSliderValueDebounced: function(mouseVal, valueVar) {
      var val = this._scale.invert(mouseVal),
          stepped = this._calcStepRounded(val),
          inputId = valueVar === 'value' ?  '#inputStart' : '#inputEnd';


      this.toggleClass('validation-error', false, this.$$(inputId));
      this.set(valueVar, stepped);
    },

    _calcStepRounded: function(value) {
      var s = Math.round(value/this.step) * this.step;
      // TODO if range, then min and max change
      // make sure it isnt rounding out of our range; might only do so by one step:
      s = s < this.min ? s + this.step : s;
      s = s > this.max ? s - this.step : s;

      return s
    },

    _valueChanged: function(v) {
      var handle = (this._isRange) ? this._startHandle : this._singleHandle;

      handle.attr("transform", "translate(" + this._scale(v) + ",0)")
    },

    _endValueChanged: function() {

    },

    _calcTransform: function() {
      return 'translate(' + this._margin.left + ',' + this._margin.top + ')';
    },

    _calcProgressStart: function() {
      if(this.endValue || this.endValue === 0) {
        return this._scale(this.value);
      }

      return 0;
    },

    _calcProgressEnd: function() {
      if(this.endValue || this.endValue === 0) {
        return this._scale(this.endValue);
      }

      return this._scale(this.value);
    },

    _updateFormat: function() {
      // if dev passed in a format, just use it
      if(this.format) {
        this.set('_format', this.format);
        return;
      }

      // otherwise figure out if we should have decimals or not
      // TODO Internationalization Comma notation?
      var s = this.step.toString().split('.'),
          l = (s.length === 2) ? s[1].length : 0,
          f = '0.';

      for(var i = 0; i < l; i++) {
        f += '0';
      }

      this.set('_format', f);
    },

    _inputChangedStart: function(evt) {
      var text = this.$$('#inputStart').value;

      this._inputChanged(text, '#inputStart', '#formatterStart', 'value');
    },

    _inputChangedEnd: function(evt) {
      var text = this.$$('#inputEnd').value;

      this._inputChanged(text, '#inputEnd', '#formatterEnd', 'endValue');
    },

    _inputChanged: function(text, inputId, formatterId, valueVar) {
      var formatter = this.$$(formatterId),
          value;

      formatter.set('unformat', text);
      value = formatter.unformattedValue;

      if(!value && value !== 0) {
        // toggle Error state
        this.toggleClass('validation-error', true, this.$$(inputId));
        this.value = null;
        return;
      }

      // make sure our value is between our max and min
      value = Math.max(value, this.min);
      value = Math.min(value, this.max);

      // make sure it matches our step
      value = this._calcStepRounded(value);

      this.toggleClass('validation-error', false, this.$$(inputId));
      /*
        in the case that you have a valid number followed by junk, eg, '25kasdjjhasdj'
        the unformatter is smart enough to throw away the chars and just keep the number
        however, this number can be the same as what was already in the box and wont clear from the box
        so reset value to force a recalc to be safe
      */
      this.value = null;
      this.set(valueVar, value);
    }

  });
</script>
