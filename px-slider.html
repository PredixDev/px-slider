
<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs
    See https://github.sw.ge.com/jreichenberg/grunt-dep-serve#why-do-we-need-this
-->
<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="px-handle.html"/>


<!--
Element providing solution to no problem in particular. As a simple, increments a counter when clicked.

##### Usage

    <px-slider counter-value="1">Hi</px-slider>

@element px-slider
@blurb Element providing solution to no problem in particular.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-slider">
    <link rel="import" type="css" href="css/px-slider.css"/>
    <template>
        <div class="flex">
        <input id="inputStart" 
          type="text" 
          class="slider-value start-value" 
          value="{{value}}" 
          on-change="handleStartChange" />
        <div id="sliderContainer" 
          class="slider flex__item">
            <div id="sliderSelected"
              class="slider-selected"></div>
            <px-handle id="startHandle" 
              style="visibility:hidden;"
              handle-track-event-name="handleTrackStart"
              on-track="handleTrackStart"></px-handle>
            <px-handle id="endHandle" 
              handle-track-event-name="handleTrackEnd"
              on-track="handleTrackEnd"></px-handle>
        </div>
        <input id="inputEnd" 
          type="text" 
          style="visibility:hidden;"
          class="slider-value end-value" 
          value="{{endValue}}" 
          on-change="handleEndChange" />
    </div>
    </template>
</dom-module>

<script>
    Polymer({

        is: 'px-slider',

        ready: function() {
            // Do we have a start value and end value?
            if (this.startValue && this.endValue) {
                // If so, this is a range.
                this._setRange(true);
                this.value = this.startValue;
                this.$.startHandle.style.visibility = 'visible';
                this.$.inputEnd.style.visibility = 'visible';

                // Update the handles with starting values
                this.updateHandle(this.$.startHandle, this.value);
                this.updateHandle(this.$.endHandle, this.endValue);

            } else {
                // Otherwise, it's just a single value.
                this.updateHandle(this.$.endHandle, this.value);
            }
        },

        /**
         * Properties block, expose attribute values to the DOM via 'reflect'
         *
         * @property properties
         * @type Object
         */
        properties: {
            range: {
                type: Boolean,
                value: false,
                readOnly: true
            },
            value: {
                type: Number,
                reflect: true,
                observer: '_valueChanged'
            },
            startValue: {
                type: Number,
                reflect: true
            },
            endValue: {
                type: Number,
                reflect: true,
                observer: '_endValueChanged'
            },
            min: {
                type: Number,
                value: 1,
                reflect: true
            },
            max: {
                type: Number,
                value: 100,
                reflect: true
            },
            step: {
                type: Number,
                value: 1,
                reflect: true
            },
            disabled: {
                type: Boolean,
                value: false,
                reflect: true
            }
        },

        /**
         * Watchers (creepy)
         *
         * Not working, though ... 
         *
         */
        _valueChanged: function(newValue, oldValue) {
            var clean = this.cleanValue(newValue);

            // For ranges, update the start value so the user can refer to it too
            this.startValue = newValue;
            //return newValue;
        },

        _endValueChanged: function(newValue, oldValue) {
            this.endValue = this.cleanValue(newValue);
            //return this.cleanValue(newValue);
        },

        cleanValue: function(dirty) {
            var clean = dirty;

            // Account for 'steps'
            var stepchange = dirty % this.step;
            clean -= stepchange;
            if ( stepchange > (this.step / 2) ) {
                clean += this.step;
            }

            // Check against min and max values
            if ( dirty > this.max ) {
                clean = this.max;
            } else if ( dirty < this.min ) {
                clean = this.min;
            }

            return clean;
        },

        translateValueToPosition: function(myvalue) {
            var cW = this.$.sliderContainer.offsetWidth;

            // What is the ratio of the value to the max?
            var ratio = myvalue / this.max;

            // Multiple by the width of the container
            var position = ratio * cW;

            return position + 'px';
        },

        translatePositionToValue: function(mypos) {
            var cW = this.$.sliderContainer.offsetWidth;

            // What is the ratio of my position to the container?
            var ratio = mypos / cW;

            // Convert to value; have to account min values other than 0
            var value = ratio * (this.max - this.min);

            return this.cleanValue(value);
        },

        updateHandle: function(handle, value) {
            // Determine new x position form value
            var newPos = this.translateValueToPosition(value);

            // Set px value of left position
            handle.style.left = newPos;

            // Update the progress bar, too
            this.updateProgressBar();
        },

        /** 
         * Update the progress bar based on change in values
         *
         * @method handleChange
         */
        updateProgressBar: function() {
            // Am I a range or a single value?
            var progressValue = (this.range) ? this.endValue - this.value: this.value;
            var progressPosition = (this.range) ? this.value: 0;

            // Set the width and the position (for ranges)
            this.$.sliderSelected.style.width = this.translateValueToPosition(progressValue);
            this.$.sliderSelected.style.left = this.translateValueToPosition(progressPosition);
        },

        /** 
         * Where is the mouse in relation to the slider? Keep it in bounds.
         *
         * @method handleChange
         */
        findPosition: function(event) {
            var mX = event.detail.x;
            var cL = this.$.sliderContainer.getBoundingClientRect().left;
            var cR =  this.$.sliderContainer.getBoundingClientRect().right;
            var cW = this.$.sliderContainer.offsetWidth;
            var position = 0;

            if (mX > cR) {
                // Is the mouse passed the right of our container?
                // If so, set the position to the width of the container
                position = cW;
            } else if (mX < cL) {
                // Is the mouse passed the left of our container?
                // If so, set the position to zero
                position = 0;
            } else {
                // Otherwise, position is based on the mouseX minus the offset
                position = mX - cL;
            }

            return position;
        },

        /** 
         * Handles updating the value when the START handle is moved
         *
         * @method handleChange
         */
        handleTrackStart: function(event, detail, sender) {
            var newPos = this.findPosition(event);

            // Update the value for the new position
            var newValue = this.translatePositionToValue(newPos);

            // We know this is range
            if (newValue > this.endValue) {
                newValue = this.endValue;
            }
            this.value = newValue;

            // Move the handle to the mouse
            this.updateHandle( this.$.startHandle, newValue );
        },

        /** 
         * Handles updating the value when the END handle is moved
         *
         * @method handleEndChange
         */
        handleTrackEnd: function(event, detail, sender) {
            var newPos = this.findPosition(event);

            // Update the value based on the new position
            var newValue = this.translatePositionToValue(newPos);
            if (this.range) {
                if (newValue < this.value) {
                    newValue = this.value;
                }
                this.endValue = newValue;
            } else {
                this.value = newValue;
            }

            // Move the handle to the mouse
            this.updateHandle( this.$.endHandle, newValue );
        },

        /** 
         * Handles updating the value when the input textbox is changed
         *
         * @method handleStartChange
         */
        handleStartChange: function(event, detail, sender) {

            // Two way data binding not working?
            this.value = this.$.inputStart.value;

            // If this is a range, check for going beyond end value
            if (this.range && this.value > this.endValue) {
                this.value = this.endValue;
            }

            // If it's a range, we update the start handle; otherwise update the end handle
            var handle = (this.range) ? this.$.startHandle : this.$.endHandle;
            this.updateHandle( handle, this.value );
        },

        /** 
         * Handles updating the value when the END input textbox is changed
         *
         * @method handleEndChange
         */
        handleEndChange: function(event, detail, sender) {

            // Two way data binding not working?
            this.endValue = this.$.inputEnd.value;

            // If this is a range, don't go below the start value
            if (this.range && this.endValue < this.value) {
                this.endValue = this.value;
            }

            // Update the end handle
            this.updateHandle( this.$.endHandle, this.endValue );
        }
    });
</script>
